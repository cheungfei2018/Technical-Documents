1. 内存泄漏：
	程序的运行需要内存。只要程序提出要求，操作系统或者运行时（runtime）就必须供给内存。
	对于持续运行的服务进程（daemon），必须及时释放不再用到的内存。否则，内存占用越来越高，轻则影响系统性能，重则导致进程崩溃。
	不再用到的内存，没有及时释放，就叫做内存泄漏（memory leak）
	
大多数语言提供自动内存管理，减轻程序员的负担，这种称为"垃圾回收机制"(garbage oollector)


2. 垃圾回收机制：
	垃圾回收机制查看内存最常用的方法叫做“引用计数”:
		语言引擎有一张"引用表"，保存了内存里面所有的资源（通常是各种值）的引用次数。如果一个值的引用次数是0，就表示这个值不再用到了，因此可以将这块内存释放。
	当没有任何引用时，引用次数为0，可以释放
	如果一个值不再需要了，引用数却不为0，垃圾回收机制无法释放这块内存，从而导致内存泄漏。
	并不是说有了垃圾回收机制，程序员就轻松了。你还是需要关注内存占用：那些很占空间的值，一旦不再用到，你必须检查是否还存在对它们的引用。如果是的话，就必须手动解除引用。
	

3. 内存泄漏的识别方法
	如果连续五次垃圾回收，内存占用一次比一次打，就存在内存泄漏，这就要求实时查看内存使用
	
	3.1浏览器
	3.2命令行：可使用node提供的process.memoryUsage()方法
	
	3.3weakMap：
		及时清除引用非常重要。但是，你不可能记得那么多，有时候一疏忽就忘了，所以才有那么多内存泄漏。
		最好能有一种方法，在新建引用的时候就声明，哪些引用必须手动清除，哪些引用可以忽略不计，当其他引用消失以后，垃圾回收机制就可以释放内存。这样就能大大减轻程序员的负担，你只要清除主要引用就可以了。
		ES6 考虑到了这一点，推出了两种新的数据结构：WeakSet 和 WeakMap。它们对于值的引用都是不计入垃圾回收机制的，所以名字里面才会有一个"Weak"，表示这是弱引用。
	
	
	
	
	