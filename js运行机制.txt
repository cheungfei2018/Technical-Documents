JS 运行机制

1.js单线程：单线程是JS的一大特点，也就是同一时间只能做一件事
	这与它的用途有关，js是浏览器脚本语言，js的主要用途是与用户交互，以及操作DOM，这决定了只能使用单线程，否则会带来复杂的同步问题；如，假如js同时有两个线程，一个线程在DOM节点上添加内容，另一个线程删除这个节点，那浏览器应该以哪个线程为主。所以为了避免复杂性，js就是单线程
	在HTML5中提出了webworker标准，允许js脚本创建多线程，但是子线程完全受主线程控制，且不得操作Dom，所以没有改变js单线程的本质

2.任务队列
	由于单线程的原因，所有任务都需要排队，如果前一个任务耗时很长，后一个任务也必须一直等着。
	很多时候CPU是闲着的，但是因为IO设备很慢(如ajax从网络中读取数据)，不得不等结果出来再往下执行；所以在js设计中，这时主线程可以完全不管IO设备，挂起处于等待中的任务，先运行排在后面的任务，等IO设备反悔了结果，再回头将挂起的任务执行下去。
	所以任务分为两种，一种是同步任务(synchronous),一种是异步任务(asybchronous),同步是指在主线程上排队执行的任务，只有前一个任务执行完成后才会执行后一个任务；异步是指不进入主线程、而进入"任务队列"(task queue)的任务，只有"任务队列"通知主线程，某个异步任务可以执行了，该任务才会进入主线程执行
	
	具体来说异步执行的运行机制如下(同步执行也是如此，因为它可以被视为没有异步任务的异步执行)：
		1.所有同步任务都在主线程上执行，形成一个执行栈
		2.主线程之外，还有一个“任务队列”，只要异步任务有了运行结果，就在“任务队列”中放置一个事件
		3.一旦“执行栈”中的所有同步任务执行完毕，系统就会读取“任务队列”看看里面有哪些事件，那些对应的异步任务，于是结束等待状态，进入执行栈，开始执行
		4.主线程不断重复上面第三步
	只要主线程空了，就会去读取“任务队列”，这就是js的运行机制，这个过程不断重复
	
3.事件和回调函数：
	"任务队列"是一个事件的队列（也可以理解成消息的队列），IO设备完成一项任务，就在"任务队列"中添加一个事件，表示相关的异步任务可以进入"执行栈"了。主线程读取"任务队列"，就是读取里面有哪些事件。
	"任务队列"中的事件，除了IO设备的事件以外，还包括一些用户产生的事件（比如鼠标点击、页面滚动等等）。只要指定过回调函数，这些事件发生时就会进入"任务队列"，等待主线程读取。
	回调函数(callback)：就是那些被主线程挂起来的代码，异步任务必须制定回调函数，当主线程开始执行异步任务，就是执行对应的回调函数
	
	"任务队列"是一个先进先出的数据结构，排在前面的事件，优先被主线程读取。主线程的读取过程基本上是自动的，只要执行栈一清空，"任务队列"上第一位的事件就自动进入主线程。但是，由于存在后文提到的"定时器"功能，主线程首先要检查一下执行时间，某些事件只有到了规定的时间，才能返回主线程。
	
4.Event Loop
	主线程从“任务队列”中读取事件，这个过程是循环不断的，整个的这种运行机制又称为Event Loop(事件循环)
	主线程运行的时候，产生堆(heap)和栈(stack)，栈中的代码调用各种外部API，他们在“任务队列”中加入各种事件(click\load等)，只要栈中的代码执行完毕，主线程就回去读取“任务队列”，一次执行那些事件所对应的回调函数
	
5.定时器(timer)
	除了放置异步任务的事件，“任务队列”还可以放置定时事件，也就是指定某些代码在多少时间后执行。也就是定时器功能
	setTimeout()和setInterval()，这两个函数的内部运行机制完全一样，区别在于前者是一次性执行，后者是反复执行
		如：
		setTimeout(function(){console.log(1);}, 0);
		console.log(2);
		执行结果总是2,1，因为只有执行完第二行以后，系统才回去执行“任务队列”中的回调函数
	HTML5规定了setTimeout()的第二个参数的最小值不得低于4ms，如果低于这个值，就会自动增加
	
	
	
	
	
	
	
	
	
	
	
	
	
	